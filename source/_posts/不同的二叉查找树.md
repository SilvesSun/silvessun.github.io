---
title: 不同的二叉查找树
date: 2018-06-11 16:03:20
tags:
- 动态规划
- LeetCode
categories:
- 算法
---

## 题目
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

## 示例
```
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

## 解析
给定i(1≤i≤n), 由1...i组成的不同的二叉查找树有f(i)种, res保存不同的n时的二叉树数目

- 当i=0时, 只有空树一种, 所以f(0) = 1
- 当i=1时, f(1) = 1
- 当i=2时, 如果以2为根, 只有1为左子树一种情况, 以1为根, 只有2为右子树一种情况
- 同样的道理, 当i=3时, 考虑3种不同的根的情况:
    - 以3为根, 则1, 2节点只能在左子树, 转化为求{1, 2}节点可以组成的二叉搜索树数目, 可知为f(2)=res[2]* res[0]
    - 以2为根, 则只有1为左子树, 2为右子树一种情况, res[1] * res[1]
    - 以1为根, 2,3只能在右子树, 所以为f{2, 3}组成的数目, 为f(2). res[0] * res[2]
    - 综上, 总数为f(3) = 2f(2) + f(1) 
- 当以k为根节点时, 1=<k <= n, 此时左子树为(1, ... , k-1)共有k-1个节点, 右子树为i-k个节点. 
![f(i)](http://p3euxxfa8.bkt.clouddn.com/2018-06-11-16-32-44.png)

## 代码实现
```py

res = [0 for _ in range(n+1)]

res[0] = 1
i = 1

while i <= n:
    j = 0
    while j < i:
        res[i] += res[j] * res[i - 1 - j]
        j += 1
    i += 1
return res[n]

```